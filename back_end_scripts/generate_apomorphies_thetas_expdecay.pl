#!/usr/bin/perl

# This script reads in a table of edge weights, and then a table of internode distances, and then finally spits out several lists of events.

# Further arguments include a table of "parsimonious" edge lists, and a default distance to use.

# Functional arguments: total weight, an array of minima and an array of maxima.
# these go in the global variables: $maxdrweight @maxdrweights @mindrweights
sub dieroller{
	$roll = rand($maxdrweight);
	$retval = int ($roll/$maxdrweight*$#maxdrweights);
	$b = $#maxdrweights;
	$c = 0;
	while ($roll < $mindrweights[$retval] || $roll > $maxdrweights[$retval])	{
		if ($roll < $mindrweights[$retval]){
			$b = $retval;
			$retval = int(($retval + $c - 1)/2);
			if ($retval == $b){return $retval;}
		}
		if ($roll > $maxdrweights[$retval]){
			$c = $retval;
			$retval = int(($retval + $b + 1)/2);
			if ($retval == $c){return $retval;}
		}
	}
	return $retval;
}

# First, we read in the table of edge weights.
$tweight = 0;

open APOMFILE, $ARGV[0] or die "file not found!\n";
EDGEDONE: while (<APOMFILE>){
	print $_;
	chomp;
	if (substr($_,0,1) eq "*") {last EDGEDONE;}
	@line = split /,/;
	push @nodenums, $line[0];
#	$reversenode{$line[0]} = $#nodenums;
	$thisweight = $line[2];
	if ($thisweight + 0 == 0){$thisweight = 0.000001;}
	push @weight, $thisweight;
	$weightlookup{$line[0]} = $thisweight;
	push @weightdex1, $tweight;
	$tweight += $thisweight;
	push @weightdex2, $tweight;
}
# NOTE - the balance of APOMFILE includes the list of Apomorphies.

#Second, we load in the table of inter-edge distances.
open DISTFILE, $ARGV[1] or die "file not found!\n";
while (<DISTFILE>){
	chomp;
	@line = split;
	@items = split /,/, $line[0];
	$distance{$line[0]} = $line[2];
#	$sweight += $weightlookup{$items[0]} * $weightlookup{$items[1]};
#	$wmdist += $line[2] * $weightlookup{$items[0]} * $weightlookup{$items[1]};
}
close DISTFILE;

#$wmdist/=$sweight;
$wmdist = $ARGV[3];

# Now, we load in a table of "parsimony lists" generated by another script.
# The weights on edge edge need to be divided by their appearance in the parsiomny lists; unless they appear 0 times in which case their weight goes to 0 b/c they are never selected.
$num_parse = 0;
open PARSFILE, $ARGV[2] or die "file not found!\n";
while (<PARSFILE>){
	chomp;
	@line = split /,/;
	$num_parse++;
	@{$parses{$num_parse}} = @line;
	foreach $edge (@line){
		$parse_counts{$edge}++;
	}	
}

# First, weight the parsimony lists.
$maxparse = 0;
for ($i=0;$i<$num_parse;$i++){
	@curparse = @{$parses{$i}};
	$parse_weights[$i] = 0;
	for ($j=0; $j < $#curparse; $j++){
		${$parse_range_min[$i]}[$j] = $parse_weights[$i]; 
		$parse_weights[$i] += $weightlookup{$curparse[$j]} / $parse_counts{$curparse[$j]};
		${$parse_range_max[$i]}[$j] = $parse_weights[$i]; 
	}
	$minparseroll[$i] = $maxparse;
	$maxparse += $parse_weights[$i];
	$maxparseroll[$i] = $maxparse;
}

# The balance of APOMFILE has the actual apomorphy lists.
while (<APOMFILE>){
	@templist = split;
	$charname = shift @templist;
	$qmax = $#templist;
	for ($theta = 0; $theta <= 10; $theta++){
		$margin = 0;
		$max_alpha = 12;
		$min_alpha = 0;
		$alpha = 0;


		for ($i = 1; $i <= $#weight; $i++){
			$fracweight = $weight[$i] / $tweight;
			if ($fracweight > 0){
				# Modify the contribution of reldist so that theta is proportional to some relative hazard multiplier.
				# That is - pick a distance, such that theta=2 corresponds to "twice" the hazard.  Reminder to self - remember what the sign and inverseness of the hazard ratio are, do not get things upside down or backwards.
				$relweight = log($fracweight / (1 - $fracweight));
				$closedist = $wmdist;
				$foundadist = 0;
				for ($qcounter = 0; $qcounter <= $qmax; $qcounter++){
					if (exists $distance{$nodenums[$i] . "," . $templist[$qcounter]} && $distance{$nodenums[$i] . "," . $templist[$qcounter]} < $closedist){$foundadist = 1; $closedist = $distance{$nodenums[$i] . "," . $templist[$qcounter]};
					}
				}
				$closedist/=$wmdist;
				$tempdex1[$i] = $margin;
				if ($foundadist == 0){$tweightlookup{$nodenums[$i]} = exp($relweight - $alpha) / (1 + exp($relweight - $alpha);}
				else {$tweightlookup{$nodenums[$i]} = exp($relweight + $theta - exp($closedist * $theta) - $alpha) / (1 + exp($relweight + $theta - exp($closedist * $theta) - $alpha));}
				$margin += $tweightlookup{$nodenums[$i]};
				$tempdex2[$i] = $margin;
			} else {
				$tempdex1[$i] = $margin;
				$tempdex2[$i] = $margin;
				$tweightlookup{$nodenums[$i]} = 0.00001;
			}
		}

		while (abs($margin-1) > 0.01){
			if ($alpha == $max_alpha && $margin > 1){
				$max_alpha *= 1.5;	
			}

			if ($alpha == $min_alpha && $margin < 1){
				$min_alpha -= 2;
			}

			if ($margin > 1 && $alpha > $min_alpha){
				$min_alpha = $alpha;
			}
			if ($margin < 1 && $alpha < $max_alpha){
				$max_alpha = $alpha;
			}

			$alpha = ($min_alpha + $max_alpha) / 2;			
			
			$margin = 0;
			
			for ($i = 1; $i <= $#weight; $i++){
				$fracweight = $weight[$i] / $tweight;
				if ($fracweight > 0){
					$relweight = log($fracweight / (1 - $fracweight));
					$closedist = $wmdist;
					$foundadist = 0;
					for ($qcounter = 0; $qcounter <= $qmax; $qcounter++){
						if (exists $distance{$nodenums[$i] . "," . $templist[$qcounter]} && $distance{$nodenums[$i] . "," . $templist[$qcounter]} < $closedist){$foundadist = 1; $closedist = $distance{$nodenums[$i] . "," . $templist[$qcounter]};
						}
					}
					$closedist/=$wmdist;
					$tempdex1[$i] = $margin;
					if ($foundadist == 0){$tweightlookup{$nodenums[$i]} = exp($relweight - $alpha) / (1 + exp($relweight - $alpha);}
					else {$tweightlookup{$nodenums[$i]} = exp($relweight + $theta - exp($closedist * $theta) - $alpha) / (1 + exp($relweight + $theta - exp($closedist * $theta) - $alpha));}
					$margin += $tweightlookup{$nodenums[$i]};
					$tempdex2[$i] = $margin;
				} else {
					$tempdex1[$i] = $margin;
					$tempdex2[$i] = $margin;
				}
			}
		}


	$tmaxparse = 0;
	for ($i=0;$i<$num_parse;$i++){
		@curparse = @{$parses{$i}};
		$tparse_weights[$i] = 0;
		for ($j=0; $j <= $#curparse; $j++){
			${$tparse_range_min[$i]}[$j] = $tparse_weights[$i]; 
			$tparse_weights[$i] += $tweightlookup{$curparse[$j]} / $parse_counts{$curparse[$j]};
			${$tparse_range_max[$i]}[$j] = $tparse_weights[$i]; 
		}
		$tminparseroll[$i] = $tmaxparse;
		$tmaxparse += $tparse_weights[$i];
		$tmaxparseroll[$i] = $tmaxparse;
	}

# All of the above weights.
# All of the below generates the 1+3+7+15=26 trials.
	for ($numtrialsmake = 0; $numtrialsmake < $ARGV[4]; $numtrialsmake++){ 
		$isokay = 0;
		$kmax = 1;
		$k = 0;
		%seen = ();
		print "$charname,$theta,$alpha,$qmax,";
		for ($i=0;$i<26;$i++){
			if ($k >= $kmax){
				$kmax *= 2;
				$kmax++;
				print "\n";
				print "$charname,$theta,$alpha,$qmax,";	
				%seen = ();
				$k = 0;
			}

			$maxdrweight = $tmaxparse;
			@mindrweights = @tminparseroll;
			@maxdrweights = @tmaxparseroll;	
			$ppick = &dieroller();

			$maxdrweight = $tparse_weights[$ppick];
			@mindrweights = @{$tparse_range_min[$ppick]};
			@maxdrweights = @{$tparse_range_max[$ppick]};
			$a = &dieroller();

			if (!exists $seen{$a}){
				$seen{$a} = 1;
				print "$nodenums[$a],";
				$k++;	
			} else {
				$i--;
			}
			
		}		
		print "\n";
	}}
}
